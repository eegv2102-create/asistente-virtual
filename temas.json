{
  "Unidad 1: Fundamentos de la Programación Orientada a Objetos": {
    "Introducción a la POO": {
      "definición": "La Programación Orientada a Objetos (POO) es un paradigma que organiza el software en torno a objetos que combinan estado (atributos) y comportamiento (métodos).",
      "ventajas": ["Reutilización de código", "Mantenimiento más sencillo", "Escalabilidad", "Facilita el modelado del mundo real"],
      "ejemplo": "class Persona {\n  String nombre;\n  void saludar() {\n    System.out.println(\"Hola, soy \" + nombre);\n  }\n}\n\nPersona p = new Persona();\np.nombre = \"Ana\";\np.saludar();"
    },
    "Clases y Objetos": {
      "definición": "Las clases son plantillas que definen atributos y métodos. Los objetos son instancias de esas clases.",
      "ejemplo": "class Coche {\n  String marca;\n  int velocidad;\n}\n\nCoche c = new Coche();\nc.marca = \"Toyota\";\nc.velocidad = 120;"
    },
    "Encapsulamiento": {
      "definición": "Oculta los detalles internos de un objeto, permitiendo el acceso solo a través de métodos públicos.",
      "ejemplo": "class Persona {\n  private int edad;\n\n  public void setEdad(int e){ this.edad = e; }\n  public int getEdad(){ return edad; }\n}"
    }
  },
  "Unidad 2: Herencia, Polimorfismo y UML": {
    "Herencia": {
      "definición": "Permite crear nuevas clases a partir de otras existentes, reutilizando atributos y métodos.",
      "ejemplo": "class Persona {\n  String nombre;\n}\n\nclass Estudiante extends Persona {\n  String carrera;\n}"
    },
    "Polimorfismo": {
      "definición": "Capacidad de un método o clase de comportarse de diferentes formas (sobrecarga y sobreescritura).",
      "ejemplo": "class Calculadora {\n  int sumar(int a, int b){ return a+b; }\n  double sumar(double a, double b){ return a+b; }\n}"
    },
    "Clases Abstractas e Interfaces": {
      "definición": "Las clases abstractas son plantillas incompletas que deben ser heredadas. Las interfaces definen un contrato que las clases implementan.",
      "ejemplo": "abstract class Figura {\n  abstract double area();\n}\n\nclass Circulo extends Figura {\n  double radio;\n  Circulo(double r){ this.radio=r; }\n  double area(){ return Math.PI*radio*radio; }\n}\n\ninterface Animal {\n  void sonido();\n}\n\nclass Perro implements Animal {\n  public void sonido(){ System.out.println(\"Guau\"); }\n}"
    },
    "Lenguaje de Modelado Unificado (UML)": {
      "definición": "Es un lenguaje estándar de modelado para visualizar, especificar, construir y documentar sistemas de software.",
      "ejemplo": "Diagramas comunes: \n- Diagrama de Clases: representa clases y relaciones.\n- Diagrama de Casos de Uso: muestra la interacción entre actores y el sistema.\n- Diagrama de Secuencia: describe la interacción entre objetos a lo largo del tiempo."
    }
  },
  "Unidad 3: UML y Patrón MVC": {
    "Diagramas UML": {
      "definición": "Los diagramas UML permiten representar gráficamente la estructura y comportamiento de un sistema.",
      "ejemplo": "- Diagrama de Clases: muestra clases, atributos, métodos y relaciones.\n- Diagrama de Casos de Uso: actores y funcionalidades.\n- Diagrama de Secuencia: interacción temporal de objetos.\n- Diagrama de Actividad: flujo de procesos."
    },
    "Patrones de Diseño en POO": {
      "definición": "Son soluciones reutilizables a problemas comunes en el diseño de software.",
      "ejemplo": "Patrón Singleton: asegura que solo exista una instancia de una clase.\nclass Singleton {\n  private static Singleton instancia;\n  private Singleton(){}\n  public static Singleton getInstancia(){\n    if(instancia == null) instancia = new Singleton();\n    return instancia;\n  }\n}"
    },
    "Patrón MVC": {
      "definición": "Divide una aplicación en tres componentes: Modelo (datos), Vista (interfaz), Controlador (lógica).",
      "ejemplo": "// Modelo\nclass Usuario {\n  String nombre;\n}\n\n// Vista\nclass VistaUsuario {\n  void mostrar(String nombre){\n    System.out.println(\"Usuario: \"+nombre);\n  }\n}\n\n// Controlador\nclass ControladorUsuario {\n  private Usuario modelo;\n  private VistaUsuario vista;\n  ControladorUsuario(Usuario m, VistaUsuario v){ this.modelo=m; this.vista=v; }\n  void actualizarVista(){ vista.mostrar(modelo.nombre); }\n}"
    }
  },
  "Unidad 4: Acceso a Archivos y Base de Datos": {
    "Acceso a Archivos": {
      "definición": "Permite leer y escribir información persistente desde archivos en el sistema.",
      "ejemplo": "import java.io.*;\nclass LeerArchivo {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new FileReader(\"archivo.txt\"));\n    String linea;\n    while((linea=br.readLine())!=null){\n      System.out.println(linea);\n    }\n    br.close();\n  }\n}"
    },
    "Bases de Datos y ORM": {
      "definición": "El acceso a bases de datos en Java se hace con JDBC o frameworks ORM como Hibernate.",
      "ejemplo": "import java.sql.*;\nclass ConexionBD {\n  public static void main(String[] args) throws Exception {\n    Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/miBD\", \"root\", \"\");\n    Statement stmt = con.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM usuarios\");\n    while(rs.next()){\n      System.out.println(rs.getString(\"nombre\"));\n    }\n    con.close();\n  }\n}"
    },
    "Integración POO + MVC + BD": {
      "definición": "Permite combinar la lógica orientada a objetos con la arquitectura MVC y el acceso a datos.",
      "ejemplo": "MVC con base de datos: el Modelo representa la entidad y conexión, el Controlador gestiona las operaciones CRUD, la Vista muestra resultados."
    },
    "Pruebas y Buenas Prácticas": {
      "definición": "Se recomienda aplicar pruebas unitarias, integración continua y patrones de diseño para garantizar calidad del software.",
      "ejemplo": "Uso de JUnit:\nimport org.junit.*;\nclass TestSuma {\n  @Test\n  public void testSumar(){\n    Calculadora c = new Calculadora();\n    assertEquals(5, c.sumar(2,3));\n  }\n}"
    },
    "Concurrencia": {
      "definición": "La concurrencia permite ejecutar múltiples tareas simultáneamente en un programa, usando hilos o procesos.",
      "ejemplo": "class HiloEjemplo extends Thread {\n  public void run() {\n    System.out.println(\"Hilo ejecutándose\");\n  }\n}\n\nHiloEjemplo hilo = new HiloEjemplo();\nhilo.start();"
    }
  }
}